using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Net;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Mercury.Generators;

internal enum FormatType {
    Unknown,
    Exact,
    Different
}

internal readonly record struct Format {
    public readonly FormatType Type;
    public readonly int BitStart;
    public readonly int BitEnd;
    public readonly EquatableArray<int> Values;

    public Format(FormatType type, int bitStart, int bitEnd, List<int> values) {
        Type = type;
        BitStart = bitStart;
        BitEnd = bitEnd;
        Values = new EquatableArray<int>(values.ToArray());
    }
}

internal readonly record struct InstructionInfo {
    public readonly string Name;
    public readonly EquatableArray<Format> Formats;
    public readonly string ReturnType;
    public readonly string Namespace;

    public InstructionInfo(string name, string returnType, string @namespace, List<Format> formats) {
        Name = name;
        Formats = new EquatableArray<Format>(formats.ToArray());
        ReturnType = returnType;
        Namespace = @namespace;
    }
}

[Generator]
public class DisassemblerGenerator : IIncrementalGenerator {

    private const string FormatExactAttributeText =
        """
        // <auto-generated />
        using System;
        
        namespace Mercury.Generators;
        
        /// <summary>
        /// Specifies a constraint on the bit values of an instruction.
        /// </summary>
        [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
        public class FormatExactAttribute<T> : Attribute {
        
            /// <summary>
            /// Specifies that a bit span of the instruction must match any of the provided values.
            /// </summary>
            public FormatExactAttribute(int bitStart, int bitEnd, int[] values) {
                
            }
            
            /// <summary>
            /// Specifies that a bit span of the instruction must match the provided value.
            /// </summary>
            public FormatExactAttribute(int bitStart, int bitEnd, int value) {
                
            }
        }
        """;

    private const string FormatDifferentAttribute =
        """
        // <auto-generated />
        using System;
        
        namespace Mercury.Generators;
        
        /// <summary>
        /// Specifies a constraint on the bit values of an instruction. Demands
        /// that a span of the instruction must not match a value. 
        /// </summary>
        [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
        public class FormatDifferentAttribute<T> : Attribute {
        
            /// <summary>
            /// Specifies that a bit span of the instruction must not match any of the provided values.
            /// </summary>
            public FormatDifferentAttribute(int bitStart, int bitEnd, int[] values) {
                
            }
            
            /// <summary>
            /// Specifies that a bit span of the instruction must not match the provided value.
            /// </summary>
            public FormatDifferentAttribute(int bitStart, int bitEnd, int value) {
                
            }
        }
        """;
    
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(ctx => {
            ctx.AddSource("FormatExactAttribute.g.cs", SourceText.From(FormatExactAttributeText, Encoding.UTF8));
            ctx.AddSource("FormatDifferentAttribute.g.cs", SourceText.From(FormatDifferentAttribute, Encoding.UTF8));
        });

        IncrementalValuesProvider<InstructionInfo> instructions = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) => IsTargetForGeneration(node),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx)
            )
            .Where(x => x.HasValue)
            .Select((x,_) => x!.Value);

        IncrementalValueProvider<ImmutableArray<InstructionInfo>> inst = instructions.Collect();
        context.RegisterSourceOutput(inst,
            static (spc, source) => Execute(source, spc));

    }

    private static bool IsTargetForGeneration(SyntaxNode node) {
        if(node is not ClassDeclarationSyntax cds)
        {
            return false;
        }

        if (cds.AttributeLists.Count == 0) {
            return false;
        }
        
        foreach (AttributeListSyntax attributeList in cds.AttributeLists) {
            foreach (AttributeSyntax attribute in attributeList.Attributes) {
                string name = attribute.Name.ToString();
                if (name.Contains("FormatExact") || name.Contains("FormatDifferent")) {
                    return true;
                }
            }
        }
        return false;
    }
    

    private static InstructionInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext ctx) {
        ClassDeclarationSyntax cds = (ClassDeclarationSyntax)ctx.Node; // ctx.node eh classdeclarationsyntax sempre aqui
        SemanticModel semanticModel = ctx.SemanticModel;
        INamedTypeSymbol? classSymbol = semanticModel.GetDeclaredSymbol(cds) as INamedTypeSymbol;
        if (classSymbol is null) {
            return null;
        }
        
        List<Format> fmts = [];
        ITypeSymbol? returnType = null;
        foreach (AttributeData? attribute in classSymbol.GetAttributes()) {
            if (attribute.ConstructorArguments[0].Value is not int) {
                continue;
            }
            if (attribute.ConstructorArguments[1].Value is not int) {
                continue;
            }

            if (attribute.AttributeClass is null || attribute.AttributeClass.TypeArguments.Length != 1) {
                continue;
            }

            returnType = attribute.AttributeClass.TypeArguments[0]; 
            
            int bitStart = (int)attribute.ConstructorArguments[0].Value!;
            int bitEnd = (int)attribute.ConstructorArguments[1].Value!;

            List<int> values = [];
            if (attribute.ConstructorArguments[2].Kind == TypedConstantKind.Array) {
                foreach (TypedConstant value in attribute.ConstructorArguments[2].Values) {
                    values.Add((int)value.Value!);
                }
            }
            else if (attribute.ConstructorArguments[2].Value is int) {
                values.Add((int)attribute.ConstructorArguments[2].Value!);
            }
            else {
                continue;
            }

            if (bitEnd < bitStart) {
                (bitStart, bitEnd) = (bitEnd, bitStart);
            }
            
            string fullyQualifiedName = attribute.AttributeClass.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            FormatType type;
            if (fullyQualifiedName.StartsWith("global::Mercury.Generators.FormatExactAttribute<")) {
                type = FormatType.Exact;
            }else if (fullyQualifiedName.StartsWith("global::Mercury.Generators.FormatDifferentAttribute<")) {
                type = FormatType.Different;
            }
            else {
                type = FormatType.Unknown;
            }
            fmts.Add(new Format(type, bitStart, bitEnd, values));
        }

        if (returnType is null) {
            return null;
        }

        string returnTypeName = returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        string @namespace = returnType.ContainingNamespace.ToDisplayString();
        
        string name = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        
        return new InstructionInfo(name, returnTypeName, @namespace,fmts);
    }

    private static void Execute(ImmutableArray<InstructionInfo> instructions, SourceProductionContext ctx) {
        ImmutableArray<ImmutableArray<InstructionInfo>> groups = instructions
            .GroupBy(i => i.ReturnType)
            .Select(g => g.ToImmutableArray())
            .ToImmutableArray();

        if (groups.Length == 0) {
            return;
        }

        foreach (ImmutableArray<InstructionInfo> group in groups) {
            string text = CreateDisassembler(group);
            string groupNamespace = group[0].Namespace;
            ctx.AddSource($"{groupNamespace}Disassembler.g.cs", SourceText.From(text, Encoding.UTF8));
        }
    }

    private static string CreateDisassembler(ImmutableArray<InstructionInfo> instructions) {
        StringBuilder sb = new();

        foreach (InstructionInfo instruction in instructions) {
            if (instruction.Formats.Count == 0) {
                continue;
            }

            sb.Append("        // Instruction: ");
            sb.AppendLine(instruction.Name);
            // documentation
            sb.Append("        // constraints: ");
            bool firstFormat = true;
            foreach (Format format in instruction.Formats) {
                if (!firstFormat) {
                    sb.Append(" AND ");
                }

                if (format.Type == FormatType.Different) {
                    sb.Append(" NOT ");
                }

                firstFormat = false;
                sb.Append($"bits {format.BitStart}-{format.BitEnd} in (");
                bool firstValue = true;
                foreach (int value in format.Values) {
                    if (!firstValue) {
                        sb.Append(", ");
                    }

                    firstValue = false;
                    sb.Append($"0x{value:X}");
                }

                sb.Append(")");
            }

            sb.AppendLine();

            sb.Append("        if(");
            for (int i = 0; i < instruction.Formats.Count; i++) {
                Format format = instruction.Formats[i];

                if (format.Values.Count > 1) {
                    if (format.Type == FormatType.Different) {
                        sb.Append('!');
                    }
                    sb.Append('(');
                }

                for (int j = 0; j < format.Values.Count; j++) {
                    int value = format.Values[j];
                    if (j > 0) {
                        sb.Append(" || ");
                    }

                    sb.Append('(');
                    sb.Append(format.BitStart != 0 ? $"(instruction >> {format.BitStart}) " : "instruction ");
                    sb.Append($"& 0b{new string('1', format.BitEnd-format.BitStart+1)}) {(
                        format.Type == FormatType.Different && format.Values.Count == 1 ? '!' : '='
                        )}= 0x{value:X}");
                }
                
                if (format.Values.Count > 1) {
                    sb.Append(')');
                }
                
                if(i < instruction.Formats.Count - 1) {
                    sb.Append(" && ");
                }
            }
            
            sb.AppendLine(") {");
            sb.AppendLine($"            return new {instruction.Name}();");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        /*
         * 0: namespace
         * 1: return type
         * 2: method body
         * 3: return type
         * 4: return type
         */
        string text = string.Format(DisassemblerFormat,
            instructions[0].Namespace,
            instructions[0].ReturnType,
            sb,
            instructions[0].ReturnType,
            instructions[0].ReturnType);
        return text;
    }
    
    private const string DisassemblerFormat =
        """
        // <auto-generated />
        #nullable enable
        using System;
        using System.Runtime.CompilerServices;
        
        namespace {0};
        
        public static class Disassembler {{
            private static {1}? GetType(uint instruction) {{
        {2}
                return null;
            }}
            
            public static {3}? Disassemble(uint instruction) {{
                {4}? type = GetType(instruction);
                if (type is null) {{
                    return null;
                }}
                type.FromInt((int)instruction);
                return type;
            }}
        }}
        """;
}