using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Mercury.Generators;

internal readonly record struct Format {
    public readonly int BitStart;
    public readonly int BitEnd;
    public readonly EquatableArray<int> Values;

    public Format(int bitStart, int bitEnd, List<int> values) {
        BitStart = bitStart;
        BitEnd = bitEnd;
        Values = new EquatableArray<int>(values.ToArray());
    }
}

internal readonly record struct InstructionInfo {
    public readonly string Name;
    public readonly EquatableArray<Format> Formats;
    public readonly string ReturnType;
    public readonly string Namespace;

    public InstructionInfo(string name, string returnType, string @namespace, List<Format> formats) {
        Name = name;
        Formats = new EquatableArray<Format>(formats.ToArray());
        ReturnType = returnType;
        Namespace = @namespace;
    }
}

[Generator]
public class DisassemblerGenerator : IIncrementalGenerator {

    private const string FormatExactAttributeText =
        """
        // <auto-generated />
        using System;
        
        namespace Mercury.Generators;
        
        /// <summary>
        /// Specifies a constraint on the bit values of an instruction.
        /// </summary>
        [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
        public class FormatExactAttribute<T> : Attribute {
        
            /// <summary>
            /// Specifies that a bit span of the instruction must match any of the provided values.
            /// </summary>
            public FormatExactAttribute(int bitStart, int bitEnd, int[] values) {
                
            }
            
            /// <summary>
            /// Specifies that a bit span of the instruction must match the provided value.
            /// </summary>
            public FormatExactAttribute(int bitStart, int bitEnd, int value) {
                
            }
        }
        """;
    
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(ctx => {
            ctx.AddSource("FormatExactAttribute.g.cs", SourceText.From(FormatExactAttributeText, Encoding.UTF8));
        });

        IncrementalValuesProvider<InstructionInfo> instructions = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: "Mercury.Generators.FormatExactAttribute`1",
            predicate: static (_, _) => true,
            transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx)
        );
        
        IncrementalValueProvider<ImmutableArray<InstructionInfo>> inst = instructions.Collect();
        context.RegisterSourceOutput(inst,
            static (spc, source) => Execute(source, spc));

    }

    private static InstructionInfo GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext ctx) {
        List<Format> fmts = [];
        ITypeSymbol? returnType = null;
        foreach (AttributeData? attribute in ctx.Attributes) {
            if (attribute.ConstructorArguments[0].Value is not int) {
                continue;
            }
            if (attribute.ConstructorArguments[1].Value is not int) {
                continue;
            }

            if (attribute.AttributeClass is null || attribute.AttributeClass.TypeArguments.Length != 1) {
                continue;
            }

            returnType = attribute.AttributeClass.TypeArguments[0]; 
            
            int bitStart = (int)attribute.ConstructorArguments[0].Value!;
            int bitEnd = (int)attribute.ConstructorArguments[1].Value!;

            List<int> values = [];
            if (attribute.ConstructorArguments[2].Kind == TypedConstantKind.Array) {
                foreach (TypedConstant value in attribute.ConstructorArguments[2].Values) {
                    values.Add((int)value.Value!);
                }
            }
            else if (attribute.ConstructorArguments[2].Value is int) {
                values.Add((int)attribute.ConstructorArguments[2].Value!);
            }
            else {
                continue;
            }

            if (bitEnd < bitStart) {
                (bitStart, bitEnd) = (bitEnd, bitStart);
            }
            fmts.Add(new Format(bitStart, bitEnd, values));
        }

        if (returnType is null) {
            return default;
        }

        string returnTypeName = returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        string @namespace = returnType.ContainingNamespace.ToDisplayString();
        
        string name = ctx.TargetSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        
        return new InstructionInfo(name, returnTypeName, @namespace,fmts);
    }

    private static void Execute(ImmutableArray<InstructionInfo> instructions, SourceProductionContext ctx) {
        ImmutableArray<ImmutableArray<InstructionInfo>> groups = instructions
            .GroupBy(i => i.ReturnType)
            .Select(g => g.ToImmutableArray())
            .ToImmutableArray();

        if (groups.Length == 0) {
            return;
        }

        foreach (ImmutableArray<InstructionInfo> group in groups) {
            string text = CreateDisassembler(group);
            string groupNamespace = group[0].Namespace;
            ctx.AddSource($"{groupNamespace}Disassembler.g.cs", SourceText.From(text, Encoding.UTF8));
        }
    }

    private static string CreateDisassembler(ImmutableArray<InstructionInfo> instructions) {
        StringBuilder sb = new();

        foreach (InstructionInfo instruction in instructions) {
            if (instruction.Formats.Count == 0) {
                continue;
            }

            sb.Append("        // Instruction: ");
            sb.AppendLine(instruction.Name);
            // documentation
            sb.Append("        // constraints: ");
            bool firstFormat = true;
            foreach (Format format in instruction.Formats) {
                if (!firstFormat) {
                    sb.Append(" AND ");
                }

                firstFormat = false;
                sb.Append($"bits {format.BitStart}-{format.BitEnd} in (");
                bool firstValue = true;
                foreach (int value in format.Values) {
                    if (!firstValue) {
                        sb.Append(", ");
                    }

                    firstValue = false;
                    sb.Append($"0x{value:X}");
                }

                sb.Append(")");
            }

            sb.AppendLine();

            sb.Append("        if(");
            for (int i = 0; i < instruction.Formats.Count; i++) {
                Format format = instruction.Formats[i];

                if (format.Values.Count > 1) {
                    sb.Append('(');
                }

                for (int j = 0; j < format.Values.Count; j++) {
                    int value = format.Values[j];
                    if (j > 0) {
                        sb.Append(" || ");
                    }

                    sb.Append('(');
                    sb.Append(format.BitStart != 0 ? $"(instruction >> {format.BitStart}) " : "instruction ");
                    sb.Append($"& 0b{new string('1', format.BitEnd-format.BitStart+1)}) == 0x{value:X}");
                }
                
                if (format.Values.Count > 1) {
                    sb.Append(')');
                }
                
                if(i < instruction.Formats.Count - 1) {
                    sb.Append(" && ");
                }
            }
            
            sb.AppendLine(") {");
            sb.AppendLine($"            return new {instruction.Name}();");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        /*
         * 0: namespace
         * 1: return type
         * 2: method body
         * 3: return type
         * 4: return type
         */
        string text = string.Format(DisassemblerFormat,
            instructions[0].Namespace,
            instructions[0].ReturnType,
            sb,
            instructions[0].ReturnType,
            instructions[0].ReturnType);
        return text;
    }
    
    private const string DisassemblerFormat =
        """
        // <auto-generated />
        #nullable enable
        using System;
        using System.Runtime.CompilerServices;
        
        namespace {0};
        
        public static class Disassembler {{
            private static {1}? GetType(uint instruction) {{
        {2}
                return null;
            }}
            
            public static {3}? Disassemble(uint instruction) {{
                {4}? type = GetType(instruction);
                if (type is null) {{
                    return null;
                }}
                type.FromInt((int)instruction);
                return type;
            }}
        }}
        """;
}