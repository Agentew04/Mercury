using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SAAE.Generators;

internal readonly record struct RegisterDef {
    public readonly bool HasNumber;
    public readonly int Number;
    public readonly string Name;
    public readonly string EnumMemberName;
    public readonly int Size;

    public RegisterDef(string enumMemberName, string name, bool hasNumber, int number, int size) {
        EnumMemberName = enumMemberName;
        Number = number;
        HasNumber = hasNumber;
        Name = name;
        Size = size;
    }
}

internal readonly record struct EnumToGenerate {
    public readonly EquatableArray<RegisterDef> Registers;
    public readonly string FullEnumName;
    public readonly string ShortEnumName;
    public readonly string ArchitectureFieldName;
    public readonly string FullArchitectureClassName;

    public EnumToGenerate(string enumName, string shortname, List<RegisterDef> regs, string architectureFieldName, string fullArchitectureClassName) {
        Registers = new EquatableArray<RegisterDef>(regs.ToArray());
        FullEnumName = enumName;
        ShortEnumName = shortname;
        ArchitectureFieldName = architectureFieldName;
        FullArchitectureClassName = fullArchitectureClassName;
    }
}

[Generator]
public class RegisterInfoGenerator : IIncrementalGenerator{
    
    private const string RegisterInfoAttributeText = 
        """
        // <auto-generated />
        namespace SAAE.Generators {
        
            [System.AttributeUsage(System.AttributeTargets.Field)]
            public class RegisterInfoAttribute : System.Attribute {
        
                public RegisterInfoAttribute(int number, string name, int size) {
                    
                }
        
                public RegisterInfoAttribute(string name, int size) {
                    
                }
            }
        }
        """;
    
    private const string RegisterInfoDefinitionAttributeText = 
        """
        // <auto-generated />
        namespace SAAE.Generators {
        
            [System.AttributeUsage(System.AttributeTargets.Enum)]
            public class RegisterInfoDefinitionAttribute : System.Attribute {
                public RegisterInfoDefinitionAttribute(SAAE.Engine.Common.Architecture architecture) {
                    
                }
            }
        }
        """;
    
    private const string ImplementationRegisterSetFormat =
        """
        // <auto-generated />
        namespace SAAE.Engine.Common {{
            public partial class {0}RegisterHelper {{
                public static int? GetRegisterNumber({1} reg) {{
                    switch (reg) {{
        {2}
                    }}
                    return null;
                }}
                
                public static string GetRegisterName({3} reg) {{
                    switch(reg) {{
        {4}
                    }}
                    return null;
                }}
                
                public static int Get{5}Count(){{
                    return {6};
                }}
                
                public static {7}? Get{8}FromNumber(int number){{
                    switch(number) {{
        {9}
                    }}
                    return null;
                }}
                
                public static {10}? Get{11}FromName(string name){{
                    switch(name){{
        {12}
                    }}
                    return null;
                }}
            }}
        }}
        """;
    
    private const string SwitchCaseFormat =
        """
                        case {0}:
                            return {1};
        """;

    private const string SharedImplementationFormat =
        """
        // <auto-generated />
        #nullable enable
        namespace SAAE.Engine.Common {{
            public partial class {0}RegisterHelper : IRegisterHelper {{
                public static TRegister? GetRegister<TRegister>(int number) where TRegister : struct, Enum {{
        {1}
                    return null;
                }}
                
                public TRegister? GetRegisterX<TRegister>(int number) where TRegister : struct, Enum {{
                    return GetRegister<TRegister>(number);
                }}
                
                public static int? GetRegisterNumber(Enum reg) {{
        {2}
                    return null;
                }}
                
                public int? GetRegisterNumberX(Enum reg) {{
                    return GetRegisterNumber(reg);
                }}
                
                public static string GetRegisterName(Enum reg) {{
        {3}
                    throw new System.ArgumentOutOfRangeException(nameof(reg));
                }}
                
                public string GetRegisterNameX(Enum reg) {{
                    return GetRegisterName(reg);
                }}
                
                public static Enum? GetRegisterFromName(string name, Type type){{
        {4}
                    throw new System.ArgumentOutOfRangeException(nameof(name));
                }}
                
                public Enum? GetRegisterFromNameX(string name, Type type){{
                    return GetRegisterFromName(name, type);
                }}
                
                public static Enum? GetRegisterFromNumber(int number, Type type) {{         
        {5}
                    throw new System.ArgumentOutOfRangeException(nameof(type));
                }}
                
                public Enum? GetRegisterFromNumberX(int number, Type type) {{
                    return GetRegisterFromNumber(number, type);
                }}
            }}
        }}
        """;

    private const string SharedIfRegisterFormat =
        """
                    if(typeof(TRegister) == typeof({0})){{
                        return (TRegister?)(object?)Get{1}FromNumber(number);
                    }}
        """;

    private const string SharedIfNumberFormat =
        """
                    if(reg.GetType() == typeof({0})) {{
                        return GetRegisterNumber(({1})reg);
                    }}
        """;        

    private const string SharedIfNameFormat =
        """
                    if(reg.GetType() == typeof({0})) {{
                        return GetRegisterName(({1})reg);
                    }}
        """;

    private const string SharedIfInvNameFormat =
        """
                    if(type == typeof({0})) {{
                        return (Enum?)Get{1}FromName(name);
                    }}
        """;
    
    private const string SharedIfGetFromNumberFormat =
        """
                    if(type == typeof({0})) {{
                        return (Enum?)Get{1}FromNumber(number);
                    }}
        """;

    private const string ProviderFormat =
        """
        // <auto-generated />
        namespace SAAE.Engine.Common;
        
        public static class RegisterHelperProvider
        {{
            public static IRegisterHelper ProvideHelper({0} architecture)
            {{
                return architecture switch
                {{
        {1}
                    _ => throw new NotImplementedException($"No register helper implemented for architecture {{architecture}}")
                }};
            }}
        }}
        """;
    
    private const string ProviderCaseFormat =
        """
                    {0}.{1} => new {2}RegisterHelper(),
        """;
    
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(ctx => {
            ctx.AddSource("RegisterInfoDefinitionAttribute.g.cs", SourceText.From(RegisterInfoDefinitionAttributeText, Encoding.UTF8));
            ctx.AddSource("RegisterInfoAttribute.g.cs", SourceText.From(RegisterInfoAttributeText, Encoding.UTF8));
        });
        
        IncrementalValuesProvider<EnumToGenerate> enums = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: "SAAE.Generators.RegisterInfoDefinitionAttribute",
            predicate: static (_, _) => true,
            transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx)
        );
        
        context.RegisterSourceOutput(enums,
            static (spc, source) => Execute(source, spc));

        IncrementalValueProvider<ImmutableArray<EnumToGenerate>> arr = enums.Collect();
        context.RegisterSourceOutput(arr,
            static (spc, source) => Execute2(source, spc));
    }

    private static EnumToGenerate GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext ctx) {
        var eds = (EnumDeclarationSyntax)ctx.TargetNode;
        var enumSymbol = (ITypeSymbol?)ModelExtensions.GetDeclaredSymbol(ctx.SemanticModel, eds);
        
        // get architecture
        string architectureFieldName = "";
        string fullArchitectureClassName = "";  
        ImmutableArray<AttributeData> enumAttributes = enumSymbol!.GetAttributes();
        for (int i = 0; i < enumAttributes.Length; i++)
        {
            AttributeData attr = enumSymbol.GetAttributes()[i];
            TypedConstant arg = attr.ConstructorArguments[0];
            fullArchitectureClassName = arg.Type!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            int value = (int)arg.Value!;
            architectureFieldName = arg.Type.GetMembers()
                .OfType<IFieldSymbol>()
                .FirstOrDefault(f => f.HasConstantValue && (int)f.ConstantValue! == value)?.Name ?? "null";
        }
        
        // get register definitons
        List<RegisterDef> regs = [];
        for (int i = 0; i < eds.Members.Count; i++) {
            EnumMemberDeclarationSyntax member = eds.Members[i];
            IFieldSymbol? fieldSymbol = (IFieldSymbol?)ModelExtensions.GetDeclaredSymbol(ctx.SemanticModel, member);
            if (fieldSymbol is null) {
                continue;
            }
            ImmutableArray<AttributeData> attributes = fieldSymbol.GetAttributes();
            foreach (AttributeData attribute in attributes) {
                if (attribute.AttributeClass!.ToDisplayString() != "SAAE.Generators.RegisterInfoAttribute") continue;
                if (attribute.ConstructorArguments.Length == 3) {
                    regs.Add(new RegisterDef(fieldSymbol.ToDisplayString(), (string)attribute.ConstructorArguments[1].Value!, true, (int)attribute.ConstructorArguments[0].Value!, (int)attribute.ConstructorArguments[2].Value!));
                }
                else {
                    regs.Add(new RegisterDef(fieldSymbol.ToDisplayString(), (string)attribute.ConstructorArguments[0].Value!, false, -1, (int)attribute.ConstructorArguments[1].Value!));
                }
                break;
            }
        }

        return new EnumToGenerate(enumSymbol!.ToDisplayString(), enumSymbol.Name, regs, architectureFieldName, fullArchitectureClassName);
    }

    private static void Execute(EnumToGenerate enumToGenerate, SourceProductionContext ctx) {
        StringBuilder numSb = new();
        StringBuilder nameSb = new();
        StringBuilder regSb = new();
        StringBuilder nameInvSb = new();

        if (enumToGenerate.Registers.Count == 0) {
            return;
        }

        foreach (RegisterDef reg in enumToGenerate.Registers) {
            if (reg.HasNumber) {
                numSb.AppendLine(string.Format(SwitchCaseFormat,
                    /*0 field*/reg.EnumMemberName,
                    /*1 number*/reg.Number));
                regSb.AppendLine(string.Format(SwitchCaseFormat,
                    /*0 number*/reg.Number,
                    /*1 field*/reg.EnumMemberName));
            }
            nameSb.AppendLine(string.Format(SwitchCaseFormat,
                /*0 case*/$"{reg.EnumMemberName}",
                /*1 return*/$"\"{reg.Name}\""));
            nameInvSb.AppendLine(string.Format(SwitchCaseFormat,
                /*0 case*/$"\"{reg.Name}\"",
                /*1 ret*/reg.EnumMemberName));

        }

        string file = string.Format(ImplementationRegisterSetFormat,
            /*0 archname*/enumToGenerate.ArchitectureFieldName,
            /*1 enum name*/enumToGenerate.FullEnumName,
            /*2 get num cases*/numSb,
            /*3* enum name*/enumToGenerate.FullEnumName,
            /*4 get name cases*/nameSb,
            /*5 enum name*/enumToGenerate.ShortEnumName,
            /*6 reg count*/enumToGenerate.Registers.Count,
            /*7 enum name*/enumToGenerate.FullEnumName,
            /*8 enum name*/enumToGenerate.ShortEnumName,
            /*9 get reg cases*/regSb,
            /*10 enum name*/enumToGenerate.FullEnumName,
            /*11 short enum name*/enumToGenerate.ShortEnumName,
            /*12 name inverse*/nameInvSb);
        
        ctx.AddSource($"RegisterHelper.{enumToGenerate.ShortEnumName}.g.cs", SourceText.From(file, Encoding.UTF8));
    }

    private static void ExecuteManager(ImmutableArray<EnumToGenerate> enums, SourceProductionContext ctx)
    {
        if (enums.Length == 0) {
            return;
        }
        
        StringBuilder registerSb = new();
        StringBuilder numberSb = new();
        StringBuilder nameSb = new();
        StringBuilder nameInvSb = new();
        StringBuilder getRegisterFromNumberSb = new();
        foreach (EnumToGenerate enumtogen in enums) {
            registerSb.AppendLine(string.Format(SharedIfRegisterFormat,
                /*0 type*/enumtogen.FullEnumName,
                /*1 type*/enumtogen.ShortEnumName
            ));
            numberSb.AppendLine(string.Format(SharedIfNumberFormat,
                enumtogen.FullEnumName,enumtogen.FullEnumName));
            nameSb.AppendLine(string.Format(SharedIfNameFormat,
                enumtogen.FullEnumName,enumtogen.FullEnumName));
            nameInvSb.AppendLine(string.Format(SharedIfInvNameFormat,
                enumtogen.FullEnumName, enumtogen.ShortEnumName));
            getRegisterFromNumberSb.AppendLine(string.Format(SharedIfGetFromNumberFormat,
                enumtogen.FullEnumName, enumtogen.ShortEnumName));
        }

        string file = string.Format(SharedImplementationFormat,
            /*0*/enums[0].ArchitectureFieldName,
            /*1 */registerSb,
            numberSb,
            nameSb,
            nameInvSb,
            /*4*/getRegisterFromNumberSb
        );
        ctx.AddSource($"{enums[0].ArchitectureFieldName}RegisterHelper.g.cs", SourceText.From(file, Encoding.UTF8));
    }
    
    private static void Execute2(ImmutableArray<EnumToGenerate> enums, SourceProductionContext ctx)
    {
        // separar enums por arquitetura
        ImmutableArray<IGrouping<string, EnumToGenerate>> groups = enums.GroupBy(x => x.ArchitectureFieldName).ToImmutableArray();

        foreach (IGrouping<string, EnumToGenerate> t in groups)
        {
            ImmutableArray<EnumToGenerate> group = t.ToImmutableArray();
            ExecuteManager(group, ctx);
        }

        // criar agora o provider
        StringBuilder providerSb = new();
        foreach (IGrouping<string, EnumToGenerate> t in groups)
        {
            ImmutableArray<EnumToGenerate> group = t.ToImmutableArray();
            providerSb.AppendLine(string.Format(ProviderCaseFormat,
                /*0 arch class*/group[0].FullArchitectureClassName,
                /*1 arch field*/group[0].ArchitectureFieldName,
                /*2 arch field*/group[0].ArchitectureFieldName));
        }
        string file = string.Format(ProviderFormat,
            /*0 arch class*/enums[0].FullArchitectureClassName,
            /*1 cases*/providerSb);
        ctx.AddSource($"RegisterHelperProvider.g.cs", SourceText.From(file, Encoding.UTF8));
    }
}