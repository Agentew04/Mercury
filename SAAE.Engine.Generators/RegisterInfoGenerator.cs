using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SAAE.Generators;

internal readonly record struct RegisterDef {
    public readonly bool HasNumber;
    public readonly int Number;
    public readonly string Name;
    public readonly string EnumMemberName;

    public RegisterDef(string enumMemberName, string name, bool hasNumber, int number) {
        EnumMemberName = enumMemberName;
        Number = number;
        HasNumber = hasNumber;
        Name = name;
    }
}

internal readonly record struct EnumToGenerate {
    public readonly EquatableArray<RegisterDef> Registers;
    public readonly string FullEnumName;
    public readonly string ShortEnumName;

    public EnumToGenerate(string enumName, string shortname, List<RegisterDef> regs) {
        Registers = new EquatableArray<RegisterDef>(regs.ToArray());
        FullEnumName = enumName;
        ShortEnumName = shortname;
    }
}

[Generator]
public class RegisterInfoGenerator : IIncrementalGenerator{
    
    private const string RegisterInfoAttributeText = 
        """
        // <auto-generated />
        namespace SAAE.Generators {
        
            [System.AttributeUsage(System.AttributeTargets.Field)]
            public class RegisterInfoAttribute : System.Attribute {
        
                public RegisterInfoAttribute(int number, string name) {
                    
                }
        
                public RegisterInfoAttribute(string name) {
                    
                }
            }
        }
        """;
    
    private const string RegisterInfoDefinitionAttributeText = 
        """
        // <auto-generated />
        namespace SAAE.Generators {
        
            [System.AttributeUsage(System.AttributeTargets.Enum)]
            public class RegisterInfoDefinitionAttribute : System.Attribute { }
        }
        """;
    
    private const string ImplementationRegisterSetFormat =
        """
        // <auto-generated />
        namespace SAAE.Engine.Common {{
            public static partial class RegisterHelper {{
                public static int? GetRegisterNumber({0} reg) {{
                    switch (reg) {{
        {1}
                    }}
                    return null;
                }}
                
                public static string GetRegisterName({2} reg) {{
                    switch(reg) {{
        {3}
                    }}
                    return null;
                }}
                
                public static int Get{4}Count(){{
                    return {5};
                }}
                
                public static {6}? Get{7}FromNumber(int number){{
                    switch(number) {{
        {8}
                    }}
                    return null;
                }}
                
                public static {9} Get{10}FromName(string name){{
                    switch(name){{
        {11}
                    }}
                    throw new System.ArgumentOutOfRangeException(nameof(name));
                }}
            }}
        }}
        """;
    
    private const string SwitchCaseFormat =
        """
                        case {0}:
                            return {1};
        """;

    private const string SharedImplementationFormat =
        """
        // <auto-generated />
        #nullable enable
        namespace SAAE.Engine.Common {{
            public static partial class RegisterHelper {{
                public static TRegister? GetRegister<TRegister>(int number) where TRegister : struct, Enum {{
        {0}
                    return null;
                }}
                
                public static int? GetRegisterNumber(Enum reg) {{
        {1}
                    return null;
                }}
                
                public static string GetRegisterName(Enum reg) {{
        {2}
                    throw new System.ArgumentOutOfRangeException(nameof(reg));
                }}
                
                public static Enum GetRegisterFromName(string name, Type type){{
        {3}
                    throw new System.ArgumentOutOfRangeException(nameof(name));
                }}
            }}
        }}
        """;

    private const string SharedIfRegisterFormat =
        """
                    if(typeof(TRegister) == typeof({0})){{
                        return (TRegister?)(object?)Get{1}FromNumber(number);
                    }}
        """;

    private const string SharedIfNumberFormat =
        """
                    if(reg.GetType() == typeof({0})) {{
                        return GetRegisterNumber(({1})reg);
                    }}
        """;        

    private const string SharedIfNameFormat =
        """
                    if(reg.GetType() == typeof({0})) {{
                        return GetRegisterName(({1})reg);
                    }}
        """;

    private const string SharedIfInvNameFormat =
        """
                    if(type == typeof({0})) {{
                        return (Enum)Get{1}FromName(name);
                    }}
        """;
    
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(ctx => {
            ctx.AddSource("RegisterInfoDefinitionAttribute.g.cs", SourceText.From(RegisterInfoDefinitionAttributeText, Encoding.UTF8));
            ctx.AddSource("RegisterInfoAttribute.g.cs", SourceText.From(RegisterInfoAttributeText, Encoding.UTF8));
        });
        

        IncrementalValuesProvider<EnumToGenerate> enums = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: "SAAE.Generators.RegisterInfoDefinitionAttribute",
            predicate: static (_, _) => true,
            transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx)
        );
        
        context.RegisterSourceOutput(enums,
            static (spc, source) => Execute(source, spc));

        IncrementalValueProvider<ImmutableArray<EnumToGenerate>> arr = enums.Collect();
        context.RegisterSourceOutput(arr,
            static (spc, source) => Execute2(source, spc));
    }

    private static EnumToGenerate GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext ctx) {
        var eds = (EnumDeclarationSyntax)ctx.TargetNode;
        var enumSymbol = (ITypeSymbol?)ctx.SemanticModel.GetDeclaredSymbol(eds);

        List<RegisterDef> regs = [];

        for (int i = 0; i < eds.Members.Count; i++) {
            EnumMemberDeclarationSyntax member = eds.Members[i];
            IFieldSymbol? fieldSymbol = (IFieldSymbol?)ctx.SemanticModel.GetDeclaredSymbol(member);
            if (fieldSymbol is null) {
                continue;
            }
            ImmutableArray<AttributeData> attributes = fieldSymbol.GetAttributes();
            foreach (AttributeData attribute in attributes) {
                if (attribute.AttributeClass!.ToDisplayString() == "SAAE.Generators.RegisterInfoAttribute") {
                    if (attribute.ConstructorArguments.Length == 2) {
                        regs.Add(new RegisterDef(fieldSymbol.ToDisplayString(), (string)attribute.ConstructorArguments[1].Value!, true, (int)attribute.ConstructorArguments[0].Value!));
                    }
                    else {
                        regs.Add(new RegisterDef(fieldSymbol.ToDisplayString(), (string)attribute.ConstructorArguments[0].Value!, false, -1));
                    }
                    break;
                }
            }
        }

        return new EnumToGenerate(enumSymbol!.ToDisplayString(), enumSymbol.Name, regs);
    }

    private static void Execute(EnumToGenerate enumToGenerate, SourceProductionContext ctx) {
        StringBuilder numSb = new();
        StringBuilder nameSb = new();
        StringBuilder regSb = new();
        StringBuilder nameInvSb = new();

        if (enumToGenerate.Registers.Count == 0) {
            return;
        }

        foreach (RegisterDef reg in enumToGenerate.Registers) {
            if (reg.HasNumber) {
                numSb.AppendLine(string.Format(SwitchCaseFormat,
                    /*0 field*/reg.EnumMemberName,
                    /*1 number*/reg.Number));
                regSb.AppendLine(string.Format(SwitchCaseFormat,
                    /*0 number*/reg.Number,
                    /*1 field*/reg.EnumMemberName));
            }
            nameSb.AppendLine(string.Format(SwitchCaseFormat,
                /*0 case*/$"{reg.EnumMemberName}",
                /*1 return*/$"\"{reg.Name}\""));
            nameInvSb.AppendLine(string.Format(SwitchCaseFormat,
                /*0 case*/$"\"{reg.Name}\"",
                /*1 ret*/reg.EnumMemberName));

        }

        string file = string.Format(ImplementationRegisterSetFormat,
            /*0 enum name*/enumToGenerate.FullEnumName,
            /*1 get num cases*/numSb,
            /*2* enum name*/enumToGenerate.FullEnumName,
            /*3 get name cases*/nameSb,
            /*4 enum name*/enumToGenerate.ShortEnumName,
            /*5 reg count*/enumToGenerate.Registers.Count,
            /*6 enum name*/enumToGenerate.FullEnumName,
            /*7 enum name*/enumToGenerate.ShortEnumName,
            /*8 get reg cases*/regSb,
            /*9 enum name*/enumToGenerate.FullEnumName,
            /*10 short enum name*/enumToGenerate.ShortEnumName,
            /*11 name inverse*/nameInvSb);
        
        ctx.AddSource($"RegisterHelper.{enumToGenerate.ShortEnumName}.g.cs", SourceText.From(file, Encoding.UTF8));
    }

    private static void Execute2(ImmutableArray<EnumToGenerate> enums, SourceProductionContext ctx) {

        if (enums.Length == 0) {
            return;
        }
        
        StringBuilder registerSb = new();
        StringBuilder numberSb = new();
        StringBuilder nameSb = new();
        StringBuilder nameInvSb = new();
        foreach (EnumToGenerate enumtogen in enums) {
            registerSb.AppendLine(string.Format(SharedIfRegisterFormat,
                /*0 type*/enumtogen.FullEnumName,
                /*1 type*/enumtogen.ShortEnumName
            ));
            numberSb.AppendLine(string.Format(SharedIfNumberFormat,
                enumtogen.FullEnumName,enumtogen.FullEnumName));
            nameSb.AppendLine(string.Format(SharedIfNameFormat,
                enumtogen.FullEnumName,enumtogen.FullEnumName));
            nameInvSb.AppendLine(string.Format(SharedIfInvNameFormat,
                enumtogen.FullEnumName, enumtogen.ShortEnumName));
        }

        string file = string.Format(SharedImplementationFormat,
            /*0 */registerSb,
            numberSb,
            nameSb,
            nameInvSb
        );
        ctx.AddSource("RegisterHelper.g.cs", SourceText.From(file, Encoding.UTF8));
    }
}